type Course implements Node {

  nodeId: ID!
  courseId: Int!
  code: String
  name: String
  semester: String


  courseUsersByCourseId(

    orderBy: CourseUsersOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: CourseUserCondition
  ): CourseUsersConnection


  sessionsByCourseId(

    orderBy: SessionsOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: SessionCondition
  ): SessionsConnection


  tagsByCourseId(

    orderBy: TagsOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: TagCondition
  ): TagsConnection
}


input CourseCondition {

  courseId: Int


  code: String


  name: String


  semester: String
}

input CourseInput {
  courseId: Int
  code: String
  name: String
  semester: String
}


input CoursePatch {
  courseId: Int
  code: String
  name: String
  semester: String
}


type CoursesConnection {

  pageInfo: PageInfo!


  totalCount: Int


  edges: [CoursesEdge]


  nodes: [Course!]
}


type CoursesEdge {

  cursor: Cursor


  node: Course!
}


enum CoursesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  COURSE_ID_ASC
  COURSE_ID_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  SEMESTER_ASC
  SEMESTER_DESC
}

type CourseUser implements Node {

  nodeId: ID!
  courseId: Int!
  userId: String!
  status: String


  courseByCourseId: Course


  userByUserId: User
}


input CourseUserCondition {

  courseId: Int


  userId: String


  status: String
}

input CourseUserInput {
  courseId: Int!
  userId: String!
  status: String
}


input CourseUserPatch {
  courseId: Int
  userId: String
  status: String
}


type CourseUsersConnection {

  pageInfo: PageInfo!


  totalCount: Int


  edges: [CourseUsersEdge]


  nodes: [CourseUser!]
}


type CourseUsersEdge {

  cursor: Cursor


  node: CourseUser!
}


enum CourseUsersOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  COURSE_ID_ASC
  COURSE_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  STATUS_ASC
  STATUS_DESC
}


input CreateCourseInput {

  clientMutationId: String


  course: CourseInput!
}


type CreateCoursePayload {

  clientMutationId: String


  course: Course


  courseEdge(

    orderBy: CoursesOrderBy = PRIMARY_KEY_ASC
  ): CoursesEdge


  query: Query
}


input CreateCourseUserInput {

  clientMutationId: String


  courseUser: CourseUserInput!
}


type CreateCourseUserPayload {

  clientMutationId: String


  courseUser: CourseUser


  courseUserEdge(

    orderBy: CourseUsersOrderBy = PRIMARY_KEY_ASC
  ): CourseUsersEdge


  courseByCourseId: Course


  userByUserId: User


  query: Query
}


input CreateQuestionFollowerInput {

  clientMutationId: String


  questionFollower: QuestionFollowerInput!
}


type CreateQuestionFollowerPayload {

  clientMutationId: String


  questionFollower: QuestionFollower


  questionFollowerEdge(

    orderBy: QuestionFollowersOrderBy = PRIMARY_KEY_ASC
  ): QuestionFollowersEdge


  questionByQuestionId: Question


  userByFollower: User


  query: Query
}


input CreateQuestionInput {

  clientMutationId: String


  question: QuestionInput!
}


type CreateQuestionPayload {

  clientMutationId: String


  question: Question


  questionEdge(

    orderBy: QuestionsOrderBy = PRIMARY_KEY_ASC
  ): QuestionsEdge


  sessionBySessionId: Session


  userByStudent: User


  query: Query
}


input CreateQuestionTagInput {

  clientMutationId: String


  questionTag: QuestionTagInput!
}


type CreateQuestionTagPayload {

  clientMutationId: String


  questionTag: QuestionTag


  questionTagEdge(

    orderBy: QuestionTagsOrderBy = PRIMARY_KEY_ASC
  ): QuestionTagsEdge


  tagByTagId: Tag


  questionByQuestionId: Question


  query: Query
}


input CreateSessionInput {

  clientMutationId: String


  session: SessionInput!
}


type CreateSessionPayload {

  clientMutationId: String


  session: Session


  sessionEdge(

    orderBy: SessionsOrderBy = PRIMARY_KEY_ASC
  ): SessionsEdge


  courseByCourseId: Course


  query: Query
}


input CreateSessionTaInput {

  clientMutationId: String


  sessionTa: SessionTaInput!
}


type CreateSessionTaPayload {

  clientMutationId: String


  sessionTa: SessionTa


  sessionTaEdge(

    orderBy: SessionTasOrderBy = PRIMARY_KEY_ASC
  ): SessionTasEdge


  sessionBySessionId: Session


  userByTa: User


  query: Query
}


input CreateTagInput {

  clientMutationId: String


  tag: TagInput!
}


type CreateTagPayload {

  clientMutationId: String


  tag: Tag


  tagEdge(

    orderBy: TagsOrderBy = PRIMARY_KEY_ASC
  ): TagsEdge


  courseByCourseId: Course


  query: Query
}


input CreateUserInput {

  clientMutationId: String


  user: UserInput!
}


type CreateUserPayload {

  clientMutationId: String


  user: User


  userEdge(

    orderBy: UsersOrderBy = PRIMARY_KEY_ASC
  ): UsersEdge


  query: Query
}


scalar Cursor


scalar Datetime


input DeleteCourseByCourseIdInput {

  clientMutationId: String
  courseId: Int!
}


input DeleteCourseInput {

  clientMutationId: String


  nodeId: ID!
}


type DeleteCoursePayload {

  clientMutationId: String
  course: Course
  deletedCourseId: ID


  query: Query
}


input DeleteCourseUserByCourseIdAndUserIdInput {

  clientMutationId: String
  courseId: Int!
  userId: String!
}


input DeleteCourseUserInput {

  clientMutationId: String


  nodeId: ID!
}


type DeleteCourseUserPayload {

  clientMutationId: String
  courseUser: CourseUser
  deletedCourseUserId: ID


  courseByCourseId: Course


  userByUserId: User


  query: Query
}


input DeleteQuestionByQuestionIdInput {

  clientMutationId: String
  questionId: Int!
}


input DeleteQuestionFollowerByQuestionIdAndFollowerInput {

  clientMutationId: String
  questionId: Int!
  follower: String!
}


input DeleteQuestionFollowerInput {

  clientMutationId: String


  nodeId: ID!
}


type DeleteQuestionFollowerPayload {

  clientMutationId: String
  questionFollower: QuestionFollower
  deletedQuestionFollowerId: ID


  questionByQuestionId: Question


  userByFollower: User


  query: Query
}


input DeleteQuestionInput {

  clientMutationId: String


  nodeId: ID!
}


type DeleteQuestionPayload {

  clientMutationId: String
  question: Question
  deletedQuestionId: ID


  sessionBySessionId: Session


  userByStudent: User


  query: Query
}


input DeleteQuestionTagByTagIdAndQuestionIdInput {

  clientMutationId: String
  tagId: Int!
  questionId: Int!
}


input DeleteQuestionTagInput {

  clientMutationId: String


  nodeId: ID!
}


type DeleteQuestionTagPayload {

  clientMutationId: String
  questionTag: QuestionTag
  deletedQuestionTagId: ID


  tagByTagId: Tag


  questionByQuestionId: Question


  query: Query
}


input DeleteSessionBySessionIdInput {

  clientMutationId: String
  sessionId: Int!
}


input DeleteSessionInput {

  clientMutationId: String


  nodeId: ID!
}


type DeleteSessionPayload {

  clientMutationId: String
  session: Session
  deletedSessionId: ID


  courseByCourseId: Course


  query: Query
}


input DeleteSessionTaBySessionIdAndTaInput {

  clientMutationId: String
  sessionId: Int!
  ta: String!
}


input DeleteSessionTaInput {

  clientMutationId: String


  nodeId: ID!
}


type DeleteSessionTaPayload {

  clientMutationId: String
  sessionTa: SessionTa
  deletedSessionTaId: ID


  sessionBySessionId: Session


  userByTa: User


  query: Query
}


input DeleteTagByTagIdInput {

  clientMutationId: String
  tagId: Int!
}


input DeleteTagInput {

  clientMutationId: String


  nodeId: ID!
}


type DeleteTagPayload {

  clientMutationId: String
  tag: Tag
  deletedTagId: ID


  courseByCourseId: Course


  query: Query
}


input DeleteUserByNetidInput {

  clientMutationId: String
  netid: String!
}


input DeleteUserInput {

  clientMutationId: String


  nodeId: ID!
}


type DeleteUserPayload {

  clientMutationId: String
  user: User
  deletedUserId: ID


  query: Query
}


type Mutation {

  createCourseUser(

    input: CreateCourseUserInput!
  ): CreateCourseUserPayload


  updateCourseUser(

    input: UpdateCourseUserInput!
  ): UpdateCourseUserPayload


  updateCourseUserByCourseIdAndUserId(

    input: UpdateCourseUserByCourseIdAndUserIdInput!
  ): UpdateCourseUserPayload


  deleteCourseUser(

    input: DeleteCourseUserInput!
  ): DeleteCourseUserPayload


  deleteCourseUserByCourseIdAndUserId(

    input: DeleteCourseUserByCourseIdAndUserIdInput!
  ): DeleteCourseUserPayload


  createCourse(

    input: CreateCourseInput!
  ): CreateCoursePayload


  updateCourse(

    input: UpdateCourseInput!
  ): UpdateCoursePayload


  updateCourseByCourseId(

    input: UpdateCourseByCourseIdInput!
  ): UpdateCoursePayload


  deleteCourse(

    input: DeleteCourseInput!
  ): DeleteCoursePayload


  deleteCourseByCourseId(

    input: DeleteCourseByCourseIdInput!
  ): DeleteCoursePayload


  createQuestionFollower(

    input: CreateQuestionFollowerInput!
  ): CreateQuestionFollowerPayload


  updateQuestionFollower(

    input: UpdateQuestionFollowerInput!
  ): UpdateQuestionFollowerPayload


  updateQuestionFollowerByQuestionIdAndFollower(

    input: UpdateQuestionFollowerByQuestionIdAndFollowerInput!
  ): UpdateQuestionFollowerPayload


  deleteQuestionFollower(

    input: DeleteQuestionFollowerInput!
  ): DeleteQuestionFollowerPayload


  deleteQuestionFollowerByQuestionIdAndFollower(

    input: DeleteQuestionFollowerByQuestionIdAndFollowerInput!
  ): DeleteQuestionFollowerPayload


  createQuestionTag(

    input: CreateQuestionTagInput!
  ): CreateQuestionTagPayload


  updateQuestionTag(

    input: UpdateQuestionTagInput!
  ): UpdateQuestionTagPayload


  updateQuestionTagByTagIdAndQuestionId(

    input: UpdateQuestionTagByTagIdAndQuestionIdInput!
  ): UpdateQuestionTagPayload


  deleteQuestionTag(

    input: DeleteQuestionTagInput!
  ): DeleteQuestionTagPayload


  deleteQuestionTagByTagIdAndQuestionId(

    input: DeleteQuestionTagByTagIdAndQuestionIdInput!
  ): DeleteQuestionTagPayload


  createQuestion(

    input: CreateQuestionInput!
  ): CreateQuestionPayload


  updateQuestion(

    input: UpdateQuestionInput!
  ): UpdateQuestionPayload


  updateQuestionByQuestionId(

    input: UpdateQuestionByQuestionIdInput!
  ): UpdateQuestionPayload


  deleteQuestion(

    input: DeleteQuestionInput!
  ): DeleteQuestionPayload


  deleteQuestionByQuestionId(

    input: DeleteQuestionByQuestionIdInput!
  ): DeleteQuestionPayload


  createSessionTa(

    input: CreateSessionTaInput!
  ): CreateSessionTaPayload


  updateSessionTa(

    input: UpdateSessionTaInput!
  ): UpdateSessionTaPayload


  updateSessionTaBySessionIdAndTa(

    input: UpdateSessionTaBySessionIdAndTaInput!
  ): UpdateSessionTaPayload


  deleteSessionTa(

    input: DeleteSessionTaInput!
  ): DeleteSessionTaPayload


  deleteSessionTaBySessionIdAndTa(

    input: DeleteSessionTaBySessionIdAndTaInput!
  ): DeleteSessionTaPayload


  createSession(

    input: CreateSessionInput!
  ): CreateSessionPayload


  updateSession(

    input: UpdateSessionInput!
  ): UpdateSessionPayload


  updateSessionBySessionId(

    input: UpdateSessionBySessionIdInput!
  ): UpdateSessionPayload


  deleteSession(

    input: DeleteSessionInput!
  ): DeleteSessionPayload


  deleteSessionBySessionId(

    input: DeleteSessionBySessionIdInput!
  ): DeleteSessionPayload


  createTag(

    input: CreateTagInput!
  ): CreateTagPayload


  updateTag(

    input: UpdateTagInput!
  ): UpdateTagPayload


  updateTagByTagId(

    input: UpdateTagByTagIdInput!
  ): UpdateTagPayload


  deleteTag(

    input: DeleteTagInput!
  ): DeleteTagPayload


  deleteTagByTagId(

    input: DeleteTagByTagIdInput!
  ): DeleteTagPayload


  createUser(

    input: CreateUserInput!
  ): CreateUserPayload


  updateUser(

    input: UpdateUserInput!
  ): UpdateUserPayload


  updateUserByNetid(

    input: UpdateUserByNetidInput!
  ): UpdateUserPayload


  deleteUser(

    input: DeleteUserInput!
  ): DeleteUserPayload


  deleteUserByNetid(

    input: DeleteUserByNetidInput!
  ): DeleteUserPayload
}


interface Node {

  nodeId: ID!
}


type PageInfo {

  hasNextPage: Boolean!


  hasPreviousPage: Boolean!


  startCursor: Cursor


  endCursor: Cursor
}


type Query implements Node {

  node(

    nodeId: ID!
  ): Node


  allCourseUsers(

    orderBy: CourseUsersOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: CourseUserCondition
  ): CourseUsersConnection


  courseUser(

    nodeId: ID!
  ): CourseUser
  courseUserByCourseIdAndUserId(courseId: Int!, userId: String!): CourseUser


  allCourses(

    orderBy: CoursesOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: CourseCondition
  ): CoursesConnection


  course(

    nodeId: ID!
  ): Course
  courseByCourseId(courseId: Int!): Course


  allQuestionFollowers(

    orderBy: QuestionFollowersOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: QuestionFollowerCondition
  ): QuestionFollowersConnection


  questionFollower(

    nodeId: ID!
  ): QuestionFollower
  questionFollowerByQuestionIdAndFollower(questionId: Int!, follower: String!): QuestionFollower


  allQuestionTags(

    orderBy: QuestionTagsOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: QuestionTagCondition
  ): QuestionTagsConnection


  questionTag(

    nodeId: ID!
  ): QuestionTag
  questionTagByTagIdAndQuestionId(tagId: Int!, questionId: Int!): QuestionTag


  allQuestions(

    orderBy: QuestionsOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: QuestionCondition
  ): QuestionsConnection


  question(

    nodeId: ID!
  ): Question
  questionByQuestionId(questionId: Int!): Question


  allSessionTas(

    orderBy: SessionTasOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: SessionTaCondition
  ): SessionTasConnection


  sessionTa(

    nodeId: ID!
  ): SessionTa
  sessionTaBySessionIdAndTa(sessionId: Int!, ta: String!): SessionTa


  allSessions(

    orderBy: SessionsOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: SessionCondition
  ): SessionsConnection


  session(

    nodeId: ID!
  ): Session
  sessionBySessionId(sessionId: Int!): Session


  allTags(

    orderBy: TagsOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: TagCondition
  ): TagsConnection


  tag(

    nodeId: ID!
  ): Tag
  tagByTagId(tagId: Int!): Tag


  allUsers(

    orderBy: UsersOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: UserCondition
  ): UsersConnection


  user(

    nodeId: ID!
  ): User
  userByNetid(netid: String!): User


  query: Query!


  nodeId: ID!
}

type Question implements Node {

  nodeId: ID!
  questionId: Int!
  value: String
  timeEntered: Datetime
  status: String
  timeResolved: Datetime
  sessionId: Int
  student: String


  sessionBySessionId: Session


  userByStudent: User


  questionFollowersByQuestionId(

    orderBy: QuestionFollowersOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: QuestionFollowerCondition
  ): QuestionFollowersConnection


  questionTagsByQuestionId(

    orderBy: QuestionTagsOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: QuestionTagCondition
  ): QuestionTagsConnection
}


input QuestionCondition {

  questionId: Int


  value: String


  timeEntered: Datetime


  status: String


  timeResolved: Datetime


  sessionId: Int


  student: String
}

type QuestionFollower implements Node {

  nodeId: ID!
  questionId: Int!
  follower: String!


  questionByQuestionId: Question


  userByFollower: User
}


input QuestionFollowerCondition {

  questionId: Int


  follower: String
}

input QuestionFollowerInput {
  questionId: Int!
  follower: String!
}


input QuestionFollowerPatch {
  questionId: Int
  follower: String
}


type QuestionFollowersConnection {

  pageInfo: PageInfo!


  totalCount: Int


  edges: [QuestionFollowersEdge]


  nodes: [QuestionFollower!]
}


type QuestionFollowersEdge {

  cursor: Cursor


  node: QuestionFollower!
}


enum QuestionFollowersOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  QUESTION_ID_ASC
  QUESTION_ID_DESC
  FOLLOWER_ASC
  FOLLOWER_DESC
}

input QuestionInput {
  questionId: Int
  value: String
  timeEntered: Datetime
  status: String
  timeResolved: Datetime
  sessionId: Int
  student: String
}


input QuestionPatch {
  questionId: Int
  value: String
  timeEntered: Datetime
  status: String
  timeResolved: Datetime
  sessionId: Int
  student: String
}


type QuestionsConnection {

  pageInfo: PageInfo!


  totalCount: Int


  edges: [QuestionsEdge]


  nodes: [Question!]
}


type QuestionsEdge {

  cursor: Cursor


  node: Question!
}


enum QuestionsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  QUESTION_ID_ASC
  QUESTION_ID_DESC
  VALUE_ASC
  VALUE_DESC
  TIME_ENTERED_ASC
  TIME_ENTERED_DESC
  STATUS_ASC
  STATUS_DESC
  TIME_RESOLVED_ASC
  TIME_RESOLVED_DESC
  SESSION_ID_ASC
  SESSION_ID_DESC
  STUDENT_ASC
  STUDENT_DESC
}

type QuestionTag implements Node {

  nodeId: ID!
  tagId: Int!
  questionId: Int!


  tagByTagId: Tag


  questionByQuestionId: Question
}


input QuestionTagCondition {

  tagId: Int


  questionId: Int
}

input QuestionTagInput {
  tagId: Int!
  questionId: Int!
}


input QuestionTagPatch {
  tagId: Int
  questionId: Int
}


type QuestionTagsConnection {

  pageInfo: PageInfo!


  totalCount: Int


  edges: [QuestionTagsEdge]


  nodes: [QuestionTag!]
}


type QuestionTagsEdge {

  cursor: Cursor


  node: QuestionTag!
}


enum QuestionTagsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  TAG_ID_ASC
  TAG_ID_DESC
  QUESTION_ID_ASC
  QUESTION_ID_DESC
}

type Session implements Node {

  nodeId: ID!
  sessionId: Int!
  startTime: Datetime
  endTime: Datetime
  location: String
  courseId: Int


  courseByCourseId: Course


  sessionTasBySessionId(

    orderBy: SessionTasOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: SessionTaCondition
  ): SessionTasConnection


  questionsBySessionId(

    orderBy: QuestionsOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: QuestionCondition
  ): QuestionsConnection
}


input SessionCondition {

  sessionId: Int


  startTime: Datetime


  endTime: Datetime


  location: String


  courseId: Int
}

input SessionInput {
  sessionId: Int
  startTime: Datetime
  endTime: Datetime
  location: String
  courseId: Int
}


input SessionPatch {
  sessionId: Int
  startTime: Datetime
  endTime: Datetime
  location: String
  courseId: Int
}


type SessionsConnection {

  pageInfo: PageInfo!


  totalCount: Int


  edges: [SessionsEdge]


  nodes: [Session!]
}


type SessionsEdge {

  cursor: Cursor


  node: Session!
}


enum SessionsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  SESSION_ID_ASC
  SESSION_ID_DESC
  START_TIME_ASC
  START_TIME_DESC
  END_TIME_ASC
  END_TIME_DESC
  LOCATION_ASC
  LOCATION_DESC
  COURSE_ID_ASC
  COURSE_ID_DESC
}

type SessionTa implements Node {

  nodeId: ID!
  sessionId: Int!
  ta: String!


  sessionBySessionId: Session


  userByTa: User
}


input SessionTaCondition {

  sessionId: Int


  ta: String
}

input SessionTaInput {
  sessionId: Int!
  ta: String!
}


input SessionTaPatch {
  sessionId: Int
  ta: String
}


type SessionTasConnection {

  pageInfo: PageInfo!


  totalCount: Int


  edges: [SessionTasEdge]


  nodes: [SessionTa!]
}


type SessionTasEdge {

  cursor: Cursor


  node: SessionTa!
}


enum SessionTasOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  SESSION_ID_ASC
  SESSION_ID_DESC
  TA_ASC
  TA_DESC
}

type Tag implements Node {

  nodeId: ID!
  tagId: Int!
  value: String
  courseId: Int


  courseByCourseId: Course


  questionTagsByTagId(

    orderBy: QuestionTagsOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: QuestionTagCondition
  ): QuestionTagsConnection
}


input TagCondition {

  tagId: Int


  value: String


  courseId: Int
}

input TagInput {
  tagId: Int
  value: String
  courseId: Int
}


input TagPatch {
  tagId: Int
  value: String
  courseId: Int
}


type TagsConnection {

  pageInfo: PageInfo!


  totalCount: Int


  edges: [TagsEdge]


  nodes: [Tag!]
}


type TagsEdge {

  cursor: Cursor


  node: Tag!
}


enum TagsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  TAG_ID_ASC
  TAG_ID_DESC
  VALUE_ASC
  VALUE_DESC
  COURSE_ID_ASC
  COURSE_ID_DESC
}


input UpdateCourseByCourseIdInput {

  clientMutationId: String
  courseId: Int!


  coursePatch: CoursePatch!
}


input UpdateCourseInput {

  clientMutationId: String


  nodeId: ID!


  coursePatch: CoursePatch!
}


type UpdateCoursePayload {

  clientMutationId: String
  course: Course


  query: Query
}


input UpdateCourseUserByCourseIdAndUserIdInput {

  clientMutationId: String
  courseId: Int!
  userId: String!


  courseUserPatch: CourseUserPatch!
}


input UpdateCourseUserInput {

  clientMutationId: String


  nodeId: ID!


  courseUserPatch: CourseUserPatch!
}


type UpdateCourseUserPayload {

  clientMutationId: String
  courseUser: CourseUser


  courseByCourseId: Course


  userByUserId: User


  query: Query
}


input UpdateQuestionByQuestionIdInput {

  clientMutationId: String
  questionId: Int!


  questionPatch: QuestionPatch!
}


input UpdateQuestionFollowerByQuestionIdAndFollowerInput {

  clientMutationId: String
  questionId: Int!
  follower: String!


  questionFollowerPatch: QuestionFollowerPatch!
}


input UpdateQuestionFollowerInput {

  clientMutationId: String


  nodeId: ID!


  questionFollowerPatch: QuestionFollowerPatch!
}


type UpdateQuestionFollowerPayload {

  clientMutationId: String
  questionFollower: QuestionFollower


  questionByQuestionId: Question


  userByFollower: User


  query: Query
}


input UpdateQuestionInput {

  clientMutationId: String


  nodeId: ID!


  questionPatch: QuestionPatch!
}


type UpdateQuestionPayload {

  clientMutationId: String
  question: Question


  sessionBySessionId: Session


  userByStudent: User


  query: Query
}


input UpdateQuestionTagByTagIdAndQuestionIdInput {

  clientMutationId: String
  tagId: Int!
  questionId: Int!


  questionTagPatch: QuestionTagPatch!
}


input UpdateQuestionTagInput {

  clientMutationId: String


  nodeId: ID!


  questionTagPatch: QuestionTagPatch!
}


type UpdateQuestionTagPayload {

  clientMutationId: String
  questionTag: QuestionTag


  tagByTagId: Tag


  questionByQuestionId: Question


  query: Query
}


input UpdateSessionBySessionIdInput {

  clientMutationId: String
  sessionId: Int!


  sessionPatch: SessionPatch!
}


input UpdateSessionInput {

  clientMutationId: String


  nodeId: ID!


  sessionPatch: SessionPatch!
}


type UpdateSessionPayload {

  clientMutationId: String
  session: Session


  courseByCourseId: Course


  query: Query
}


input UpdateSessionTaBySessionIdAndTaInput {

  clientMutationId: String
  sessionId: Int!
  ta: String!


  sessionTaPatch: SessionTaPatch!
}


input UpdateSessionTaInput {

  clientMutationId: String


  nodeId: ID!


  sessionTaPatch: SessionTaPatch!
}


type UpdateSessionTaPayload {

  clientMutationId: String
  sessionTa: SessionTa


  sessionBySessionId: Session


  userByTa: User


  query: Query
}


input UpdateTagByTagIdInput {

  clientMutationId: String
  tagId: Int!


  tagPatch: TagPatch!
}


input UpdateTagInput {

  clientMutationId: String


  nodeId: ID!


  tagPatch: TagPatch!
}


type UpdateTagPayload {

  clientMutationId: String
  tag: Tag


  courseByCourseId: Course


  query: Query
}


input UpdateUserByNetidInput {

  clientMutationId: String
  netid: String!


  userPatch: UserPatch!
}


input UpdateUserInput {

  clientMutationId: String


  nodeId: ID!


  userPatch: UserPatch!
}


type UpdateUserPayload {

  clientMutationId: String
  user: User


  query: Query
}

type User implements Node {

  nodeId: ID!
  netid: String!
  name: String


  courseUsersByUserId(

    orderBy: CourseUsersOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: CourseUserCondition
  ): CourseUsersConnection


  sessionTasByTa(

    orderBy: SessionTasOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: SessionTaCondition
  ): SessionTasConnection


  questionsByStudent(

    orderBy: QuestionsOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: QuestionCondition
  ): QuestionsConnection


  questionFollowersByFollower(

    orderBy: QuestionFollowersOrderBy = PRIMARY_KEY_ASC


    before: Cursor


    after: Cursor


    first: Int


    last: Int


    offset: Int


    condition: QuestionFollowerCondition
  ): QuestionFollowersConnection
}


input UserCondition {

  netid: String


  name: String
}

input UserInput {
  netid: String!
  name: String
}


input UserPatch {
  netid: String
  name: String
}


type UsersConnection {

  pageInfo: PageInfo!


  totalCount: Int


  edges: [UsersEdge]


  nodes: [User!]
}


type UsersEdge {

  cursor: Cursor


  node: User!
}


enum UsersOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  NETID_ASC
  NETID_DESC
  NAME_ASC
  NAME_DESC
}
